// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package customTypes

import (
	"fmt"
	"io"
	"strconv"
)

// Add Ons
type AddonList struct {
	Name  string `json:"name"`
	Owner string `json:"owner"`
}

type AddonStatusInput struct {
	Selector            *MeshType `json:"selector"`
	KubernetesContextID string    `json:"kubernetesContextID"`
	TargetStatus        Status    `json:"targetStatus"`
}

type ApplicationPage struct {
	Page         int                  `json:"page"`
	PageSize     int                  `json:"pageSize"`
	TotalCount   int                  `json:"totalCount"`
	Applications []*ApplicationResult `json:"applications"`
}

// Applications
type ApplicationResult struct {
	ID              string      `json:"id"`
	Name            string      `json:"name"`
	ApplicationFile string      `json:"applicationFile"`
	Type            *NullString `json:"type"`
	UserID          string      `json:"userID"`
	Location        *Location   `json:"location"`
	CreatedAt       *string     `json:"createdAt"`
	UpdatedAt       *string     `json:"updatedAt"`
}

// Catalog
type CatalogFilter struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	FilterFile  string                 `json:"filterFile"`
	UserID      string                 `json:"userID"`
	Location    *Location              `json:"location"`
	Visibility  string                 `json:"visibility"`
	CatalogData map[string]interface{} `json:"catalogData"`
	CreatedAt   *string                `json:"createdAt"`
	UpdatedAt   *string                `json:"updatedAt"`
}

type CatalogPattern struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	UserID      string                 `json:"userID"`
	PatternFile string                 `json:"patternFile"`
	Location    *Location              `json:"location"`
	Visibility  string                 `json:"visibility"`
	CatalogData map[string]interface{} `json:"catalogData"`
	CreatedAt   *string                `json:"createdAt"`
	UpdatedAt   *string                `json:"updatedAt"`
}

type CatalogSelector struct {
	Search string `json:"search"`
	Order  string `json:"order"`
}

type ClusterResources struct {
	Resources []*Resource `json:"resources"`
}

// Configuration
type ConfigurationPage struct {
	Applications *ApplicationPage   `json:"applications"`
	Patterns     *PatternPageResult `json:"patterns"`
	Filters      *FilterPage        `json:"filters"`
}

type Container struct {
	ControlPlaneMemberName string           `json:"controlPlaneMemberName"`
	ContainerName          string           `json:"containerName"`
	Image                  string           `json:"image"`
	Status                 *ContainerStatus `json:"status"`
	Ports                  []*ContainerPort `json:"ports"`
	Resources              interface{}      `json:"resources"`
}

type ContainerPort struct {
	Name          *string `json:"name"`
	ContainerPort int     `json:"containerPort"`
	Protocol      string  `json:"protocol"`
}

// Define Container
type ContainerStatus struct {
	ContainerStatusName string      `json:"containerStatusName"`
	Image               string      `json:"image"`
	State               interface{} `json:"state"`
	LastState           interface{} `json:"lastState"`
	Ready               bool        `json:"ready"`
	RestartCount        interface{} `json:"restartCount"`
	Started             bool        `json:"started"`
	ImageID             interface{} `json:"imageId"`
	ContainerID         interface{} `json:"containerId"`
}

type ControlPlane struct {
	Name    string                `json:"name"`
	Members []*ControlPlaneMember `json:"members"`
}

// Control Plane
type ControlPlaneMember struct {
	Name       string       `json:"name"`
	Component  string       `json:"component"`
	Version    string       `json:"version"`
	Namespace  string       `json:"namespace"`
	DataPlanes []*Container `json:"data_planes"`
}

// Data Plane
type DataPlane struct {
	Name    string       `json:"Name"`
	Proxies []*Container `json:"proxies"`
}

// Define Error
type Error struct {
	Code        string `json:"code"`
	Description string `json:"description"`
}

type FilterPage struct {
	Page       int             `json:"page"`
	PageSize   int             `json:"pageSize"`
	TotalCount int             `json:"totalCount"`
	Filters    []*FilterResult `json:"filters"`
}

// Filters
type FilterResult struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	FilterFile  string                 `json:"filterFile"`
	UserID      string                 `json:"userID"`
	Location    *Location              `json:"location"`
	Visibility  string                 `json:"visibility"`
	CatalogData map[string]interface{} `json:"catalogData"`
	CreatedAt   *string                `json:"createdAt"`
	UpdatedAt   *string                `json:"updatedAt"`
}

type KubectlDescribeDetails struct {
	Describe  *string `json:"describe"`
	ContextID *string `json:"contextID"`
}

type KubernetesContext struct {
	ID                 string                 `json:"id"`
	Name               string                 `json:"name"`
	Auth               map[string]interface{} `json:"auth"`
	Cluster            map[string]interface{} `json:"cluster"`
	Server             string                 `json:"server"`
	Owner              string                 `json:"owner"`
	CreatedBy          string                 `json:"createdBy"`
	MesheryInstanceID  string                 `json:"mesheryInstanceID"`
	KubernetesServerID string                 `json:"kubernetesServerID"`
	DeploymentType     string                 `json:"deploymentType"`
	UpdatedAt          string                 `json:"updatedAt"`
	CreatedAt          string                 `json:"createdAt"`
}

// Kubernetes Context
type KubernetesContextsPage struct {
	TotalCount int                  `json:"totalCount"`
	Contexts   []*KubernetesContext `json:"contexts"`
}

// Location
type Location struct {
	Branch *string `json:"branch"`
	Host   *string `json:"host"`
	Path   *string `json:"path"`
	Type   *string `json:"type"`
}

type MeshSyncEvent struct {
	Type      string      `json:"type"`
	Object    interface{} `json:"object"`
	ContextID string      `json:"contextID"`
}

type MesheryControllersStatusListItem struct {
	ContextID  string                  `json:"contextID"`
	Controller MesheryController       `json:"controller"`
	Status     MesheryControllerStatus `json:"status"`
}

type MesheryResult struct {
	MesheryID          *string                `json:"mesheryID"`
	Name               *string                `json:"name"`
	Mesh               *string                `json:"mesh"`
	PerformanceProfile *string                `json:"performanceProfile"`
	TestID             *string                `json:"testID"`
	RunnerResults      map[string]interface{} `json:"runnerResults"`
	ServerMetrics      map[string]interface{} `json:"serverMetrics"`
	ServerBoardConfig  *string                `json:"serverBoardConfig"`
	TestStartTime      *string                `json:"testStartTime"`
	UserID             *string                `json:"userID"`
	UpdatedAt          *string                `json:"updatedAt"`
	CreatedAt          *string                `json:"createdAt"`
}

// Define Namespace
type NameSpace struct {
	Namespace string `json:"namespace"`
}

// NullString
type NullString struct {
	String string `json:"String"`
	Valid  *bool  `json:"Valid"`
}

// OAM Capbility
type OAMCapability struct {
	OamDefinition interface{} `json:"oamDefinition"`
	ID            *string     `json:"id"`
	OamRefSchema  *string     `json:"oamRefSchema"`
	Host          *string     `json:"host"`
	Restricted    *bool       `json:"restricted"`
	Metadata      interface{} `json:"metadata"`
}

type OperatorControllerStatus struct {
	Name      string `json:"name"`
	Version   string `json:"version"`
	Status    Status `json:"status"`
	Error     *Error `json:"error"`
	ContextID string `json:"contextID"`
}

type OperatorControllerStatusPerKubernetesContext struct {
	ContextID                string                    `json:"contextID"`
	OperatorControllerStatus *OperatorControllerStatus `json:"OperatorControllerStatus"`
}

// Operator
type OperatorStatus struct {
	Status      Status                      `json:"status"`
	Version     string                      `json:"version"`
	Controllers []*OperatorControllerStatus `json:"controllers"`
	Error       *Error                      `json:"error"`
	ContextID   string                      `json:"contextID"`
}

type OperatorStatusInput struct {
	TargetStatus string `json:"targetStatus"`
	ContextID    string `json:"contextID"`
}

type OperatorStatusPerKubernetesContext struct {
	ContextID      string          `json:"contextID"`
	OperatorStatus *OperatorStatus `json:"operatorStatus"`
}

type PageFilter struct {
	Page     string  `json:"page"`
	PageSize int     `json:"pageSize"`
	Order    *string `json:"order"`
	Search   *string `json:"search"`
	From     *string `json:"from"`
	To       *string `json:"to"`
}

// Patterns
type PatternPage struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	UserID      string                 `json:"userID"`
	Location    *Location              `json:"location"`
	PatternFile string                 `json:"patternFile"`
	Visibility  string                 `json:"visibility"`
	CatalogData map[string]interface{} `json:"catalogData"`
	CanSupport  bool                   `json:"canSupport"`
	Errmsg      *string                `json:"errmsg"`
	CreatedAt   *string                `json:"createdAt"`
	UpdatedAt   *string                `json:"updatedAt"`
}

type PatternPageResult struct {
	Page       int              `json:"page"`
	PageSize   int              `json:"pageSize"`
	TotalCount int              `json:"totalCount"`
	Patterns   []*PatternResult `json:"patterns"`
}

type PatternResult struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	UserID      string                 `json:"userID"`
	Location    *Location              `json:"location"`
	PatternFile string                 `json:"patternFile"`
	Visibility  string                 `json:"visibility"`
	CatalogData map[string]interface{} `json:"catalogData"`
	CanSupport  bool                   `json:"canSupport"`
	Errmsg      *string                `json:"errmsg"`
	CreatedAt   *string                `json:"createdAt"`
	UpdatedAt   *string                `json:"updatedAt"`
}

type PerfPageProfiles struct {
	Page       int            `json:"page"`
	PageSize   int            `json:"pageSize"`
	TotalCount int            `json:"totalCount"`
	Profiles   []*PerfProfile `json:"profiles"`
}

// Performance
type PerfPageResult struct {
	Page       int              `json:"page"`
	PageSize   int              `json:"pageSize"`
	TotalCount int              `json:"totalCount"`
	Results    []*MesheryResult `json:"results"`
}

type PerfProfile struct {
	ConcurrentRequest int       `json:"concurrentRequest"`
	CreatedAt         *string   `json:"createdAt"`
	Duration          string    `json:"duration"`
	Endpoints         []*string `json:"endpoints"`
	ID                string    `json:"id"`
	LastRun           *string   `json:"lastRun"`
	LoadGenerators    *string   `json:"loadGenerators"`
	Name              *string   `json:"name"`
	QPS               *int      `json:"qps"`
	TotalResults      *int      `json:"totalResults"`
	UpdatedAt         *string   `json:"updatedAt"`
	UserID            *string   `json:"userID"`
	RequestHeaders    *string   `json:"request_headers"`
	RequestCookies    *string   `json:"request_cookies"`
	RequestBody       *string   `json:"request_body"`
	ContentType       *string   `json:"content_type"`
	ServiceMesh       *string   `json:"service_mesh"`
}

// Dashboard
type Resource struct {
	Kind  string `json:"kind"`
	Count int    `json:"count"`
}

// ReSync
type ResyncActions struct {
	ClearDb   string `json:"clearDB"`
	Resync    string `json:"Resync"`
	HardReset string `json:"hardReset"`
}

// Service Mesh Filtering
type ServiceMeshFilter struct {
	Type                 *MeshType `json:"type"`
	KubernetesClusterIds []string  `json:"kubernetesClusterIds"`
}

// MeshType indicates the type of Service Mesh
type MeshType string

const (
	MeshTypeAllMesh            MeshType = "ALL_MESH"
	MeshTypeInvalidMesh        MeshType = "INVALID_MESH"
	MeshTypeAppMesh            MeshType = "APP_MESH"
	MeshTypeCiliumServiceMesh  MeshType = "CILIUM_SERVICE_MESH"
	MeshTypeCitrixServiceMesh  MeshType = "CITRIX_SERVICE_MESH"
	MeshTypeConsul             MeshType = "CONSUL"
	MeshTypeIstio              MeshType = "ISTIO"
	MeshTypeKuma               MeshType = "KUMA"
	MeshTypeLinkerd            MeshType = "LINKERD"
	MeshTypeNetworkServiceMesh MeshType = "NETWORK_SERVICE_MESH"
	MeshTypeNginxServiceMesh   MeshType = "NGINX_SERVICE_MESH"
	MeshTypeOctarine           MeshType = "OCTARINE"
	MeshTypeOpenServiceMesh    MeshType = "OPEN_SERVICE_MESH"
	MeshTypeTanzu              MeshType = "TANZU"
)

var AllMeshType = []MeshType{
	MeshTypeAllMesh,
	MeshTypeInvalidMesh,
	MeshTypeAppMesh,
	MeshTypeCiliumServiceMesh,
	MeshTypeCitrixServiceMesh,
	MeshTypeConsul,
	MeshTypeIstio,
	MeshTypeKuma,
	MeshTypeLinkerd,
	MeshTypeNetworkServiceMesh,
	MeshTypeNginxServiceMesh,
	MeshTypeOctarine,
	MeshTypeOpenServiceMesh,
	MeshTypeTanzu,
}

func (e MeshType) IsValid() bool {
	switch e {
	case MeshTypeAllMesh, MeshTypeInvalidMesh, MeshTypeAppMesh, MeshTypeCiliumServiceMesh, MeshTypeCitrixServiceMesh, MeshTypeConsul, MeshTypeIstio, MeshTypeKuma, MeshTypeLinkerd, MeshTypeNetworkServiceMesh, MeshTypeNginxServiceMesh, MeshTypeOctarine, MeshTypeOpenServiceMesh, MeshTypeTanzu:
		return true
	}
	return false
}

func (e MeshType) String() string {
	return string(e)
}

func (e *MeshType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MeshType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MeshType", str)
	}
	return nil
}

func (e MeshType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MesheryController string

const (
	MesheryControllerBroker   MesheryController = "BROKER"
	MesheryControllerOperator MesheryController = "OPERATOR"
	MesheryControllerMeshsync MesheryController = "MESHSYNC"
)

var AllMesheryController = []MesheryController{
	MesheryControllerBroker,
	MesheryControllerOperator,
	MesheryControllerMeshsync,
}

func (e MesheryController) IsValid() bool {
	switch e {
	case MesheryControllerBroker, MesheryControllerOperator, MesheryControllerMeshsync:
		return true
	}
	return false
}

func (e MesheryController) String() string {
	return string(e)
}

func (e *MesheryController) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MesheryController(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MesheryController", str)
	}
	return nil
}

func (e MesheryController) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MesheryControllerStatus string

const (
	MesheryControllerStatusDeployed    MesheryControllerStatus = "DEPLOYED"
	MesheryControllerStatusNotdeployed MesheryControllerStatus = "NOTDEPLOYED"
	MesheryControllerStatusDeploying   MesheryControllerStatus = "DEPLOYING"
	MesheryControllerStatusUnknown     MesheryControllerStatus = "UNKNOWN"
)

var AllMesheryControllerStatus = []MesheryControllerStatus{
	MesheryControllerStatusDeployed,
	MesheryControllerStatusNotdeployed,
	MesheryControllerStatusDeploying,
	MesheryControllerStatusUnknown,
}

func (e MesheryControllerStatus) IsValid() bool {
	switch e {
	case MesheryControllerStatusDeployed, MesheryControllerStatusNotdeployed, MesheryControllerStatusDeploying, MesheryControllerStatusUnknown:
		return true
	}
	return false
}

func (e MesheryControllerStatus) String() string {
	return string(e)
}

func (e *MesheryControllerStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MesheryControllerStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MesheryControllerStatus", str)
	}
	return nil
}

func (e MesheryControllerStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define Status
type Status string

const (
	StatusEnabled    Status = "ENABLED"
	StatusConnected  Status = "CONNECTED"
	StatusDisabled   Status = "DISABLED"
	StatusProcessing Status = "PROCESSING"
	StatusUnknown    Status = "UNKNOWN"
)

var AllStatus = []Status{
	StatusEnabled,
	StatusConnected,
	StatusDisabled,
	StatusProcessing,
	StatusUnknown,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusEnabled, StatusConnected, StatusDisabled, StatusProcessing, StatusUnknown:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
